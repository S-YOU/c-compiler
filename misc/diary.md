# C(のサブセット)コンパイラ開発日記

## 2018年7月8日 (Day 1)

- VirtualBoxにUbuntuを入れるのに失敗した。しかたがないのでmacOSで開発する。まあ関数呼び出しとか実装するようになるのはもっと後の話だろうし。

- 課題1（標準入力で数値を受け取り、その数値をreturnする関数のコードを吐く）。やるだけ。入力に乱数を入れたくて、ググったとおりに適当にやったが、なんか上手く行かなかった。macOSのbashの仕様が違うのかもしれないし、私がbashを理解していないのかもしれない。両方か。

- `+` と `-` だけがあるlexerを実装。

- 課題2。とりあえずCPUをスタックマシンにするために頑張ろう。[Compiler Explorer](https://godbolt.org/)のコードを見て、見よう見まねでpushとか演算とかが実装できるようになった。チラ見した他の人のコードには普通に `push` みたいなニーモニックが書いてあったが、まあとりあえず動けばよかろうなのだ。

- lexerとスタックマシンができたのだから、あとは中置をRPNにするだけ。再帰下降パーサーを書けばいいのだが、何を思ったかshunting-yardを実装（しかもまだvectorが無いので有限長の配列）。どうせどこかで挫折するんだろうなぁ

- 無事動いた。やったぜ。

- vectorが欲しいけど、つらくかなしい `void*` よりはメタプログラミングの方がまだマシでは。

- vectorを無事shunting-yardに組み込むことに成功。これにて今日は終わり。

## 2018年7月9日 (Day 2)

- 8日の日記を書いた後に、コードをきれいにして、さらに掛け算を実装。

- 用事とか誕生日とかがあったのでそんなに組めていない。まあ今日はこんなもんでいいや。

- 新機能としては、掛け算が増え、一般に複数の優先順位にだいたい対応できたということぐらいである。どちらかというとコード美化をした一日だった。

## 2018年7月10日

- まったりしていたので進捗なし。たまにはこういう日もある。

## 2018年7月11日 (Day 3)

- まったりしていたらみなさんがとても進捗を出しているの図。

- とりあえず、パーサー拡充して演算子だけでも処理するか。演算子は大量にあるけれど代入とかを除けばだいたい同じだし。

- 除算・剰余・カンマを実装。じゃあ次は比較演算子を実装して2文字の演算子について考えることとするか

- 比較演算子( `< <= > >= == !=` ) と ビット演算子( `& | << >>` ) を実装する途中で、スペースも処理するようにした。

- 単項演算子( `! ~` )を実装したところで、そろそろ変数とかの方に移っていこうか。

## 2018年7月12日 (Day 4)

### 連想配列の実装
- 寝て起きたので日が変わっている。えーと連想配列組まなきゃなんだよな。

- `(char *, int)`というペアの配列で実装しろとのことなので、vectorテンプレートを使う。オレオレテンプレート、やはり便利。

- 実装できたと思う。テストも書いた。

### ローカル変数の実装
- ローカル変数を処理できるようにしよう。%rbpはローカル変数の処理に使うべきで、固定しておくべきっぽいので、いままで%rbpを上下させて実装していたスタックマシンを、%rspを上下させるような仕様に変更。

- 領域を確保するコードを正しく実装できた。さて次はlexerを変数に対応させよう。

- 変数に対応させようとしたら、なんか16進数と8進数が実装されていた。変数に対応させよう。

- とりあえずパーサーが変数を読めるようにした。

### リポジトリ美化

- テストファイルの命名に一貫性がないこと、自動生成されている`.s`が.gitignoreされていないことに関して指摘を受けたので訂正。

### ローカル変数の実装

- さてさて。ローカル変数の実装だ。そろそろshunting-yardだと支障をきたし始める頃だろうか。知らんけど。

## 2018年7月13日 (Day 5)

### ローカル変数の実装

- アセンブリを書いてみたところ、まあ当然右辺値として使うかどうかによって文脈判断が要るので、再帰下降にするしかないことが確定。まあそれはそうだった。最初から再帰下降にしておけばよかったのに。

### リポジトリ美化part2

- 空白はトークンではないのでlexerから削除。

- ヘッダファイルを合流させた。

- テストをまとめたり減らしたりした。
	* 出力ファイルにデバッグ情報を埋め込むことで、わざわざテストをしなくてもデバッグしやすいようになった。
	* `--lexer-debug` オプションを実装することで、わざわざテストをしなくてもデバッグしやすいようになった。
	* それによって不要になったテストを削除。`print_assembly_check009` はcheckではなくsandboxなので、そう改名。

- clang-formatを使用。

- 再帰下降で全部書き直すことに成功。

### 機能追加

- 再帰下降にしたので単項`+`と単項`-`が実装できるように。よって実装。

- 複文を実装。「最後の評価値を戻り値にする」をそのままやるのが面倒だったため、`return`も追加した。`return`の後に更に文が来たときの挙動は現状では未定義とする（実情としては、「評価されるが」返り値には影響を与えない、みたいな挙動になるはず）→ラベル足せばいいことに気づいたので足す。

- 変数aと変数bを使って処理ができるように。

- 任意の名前の変数を許容。

- `^`を実装、さらに条件演算子を実装。

## 2018年7月14日 (Day 6)

### 関数呼び出し

- 関数呼び出しを実装。関数定義ができないので、常に`87`を返す組み込み関数`always87()`を実装することで凌ぐ。

- 引数付きの関数呼び出しを実装。

## 2018年7月15日 (Day 7)

- `parse_compound_statement` を足して、それで全体をparseするように。

- 複数の関数定義（引数なし）をパースできるように。

- 複数の関数定義（引数あり）をパースできるようになり、フィボナッチに成功。

- `&&` を実装。`3 && 2 && 5`とかでも通る。

- `||` を実装。`3 || 2 || 5`とかでも通る。

- `+=` を実装。

- `-=` `*=` `/=` `%=` `<<=` `>>=` `&=` `^=` `|=` を実装。

- `if` - `else` を実装。ちゃんと最も内側の`if`に`else`がくっつく。

- 関数内に複数のルートができたということなので、同一関数内の`return`は必ず同じ場所に返るように修正。

## 2018年7月16日

- 徹夜 → 15:00まで外出 → ( ˘ω˘)ｽﾔｧ

## 2018年7月17日 (Day 8)

- `do` - `while` を実装。

- `while` を実装。また、`;`とコンマ演算子はやっぱり挙動が異なるべきなので、修正。

- `break` を実装。多分。二重ループでもちゃんと正しく動いてるっぽいのでOK。

- `continue` を実装。

## 2018年7月18日 (Day 9)

- バグが検出されたので直した。do-whileの末尾でスタックを余計に押し下げていて、ローカル変数の領域を破壊していたのが原因だった。

- いい加減vectorを`void *`に統一しなければならないので、その移行の準備をした。

- 前置・後置の`++` と `--` を実装。

- 「lexerを2回実行して、1回目でトークン数を数えて2回目でその分をcallocする」とすれば `vector_Token` が不要になるので、そうした。

- intmap以外でのvectorの使用を廃することに成功したので、vectorをintmapの中に放り込んで怒涛のinline化。そしてリポジトリからテンプレート機構を削除。

- 第三式が無いfor文を実装。

- 第三式があるときにもfor文を実装。（あれ、コメントアウトで書いているけど2重ループでマズいのでは）（←大丈夫。第三式自体にforが出なければよくて、forは文なので第三式には出てこない）

## 2018年7月19日 (Day 10)

- ソースコードから配列を追放。これで多分すべての変数宣言が `型名 名前;` と見なせる

- `型名 名前;` を構文解析

- `int_map` は `int` じゃなくて `void*` を取るように。それに沿って `map` に改名。

- 変数が宣言されていないとエラーになるようにした。

### スコープ

- ちゃんとスコープを見てやらねばなのである。ということで、現状の `map` での管理では限界があろう。ブロックの内外で変数名が衝突することもあるのだし。

- 変数用の領域を確保する処理は割と現状のままでよくて（現状だと多めに取ることになるが、多い分には困らない）、名前解決を直さねば。

- 現状では、関数に入る際に、それ以降に登場する全ての識別子を数え、それに `offset` を振っている。しかしこれだとスコープの内外で変数名が衝突したときに困るので、最初は全ての識別子を重複を含めて数え、 `offset` は振らないでおく。

- まずデータ構造を考えよう。中から外を見なければいけないが、外からは中は見えなくて良い。ということで、外へ外へと伸びていくリンクリストにすればよさそうではある。

- さてどう移行していこうか。とりあえず `var_table` を `old_var_table` にしよう。次に、 `capacity` の確保をする際には重複して数えるようにしよう。

- とりあえず片方向リンクリストの型を入れておいた。まだリンクリストにはなっていないけど。

- `isDeclared` を一旦捨てて、直に `offset` を`void*`にキャストする方針へ。これにより`calloc`を廃す。

- 宣言されてから初めて`insert`するようにした。動いた。

- 多分リンクリストが実装できた。知らんけど。

- スコープチェーンが動いていることを確認。

### 雑多

- ついでに、関数名の前に型を要求。これで `supplement.c` を自力でコンパイルできるように。

- 誤ったCに対してエラーを吐く方に関してはテストをしていなかったので、テストをしようとしたところ、continue_label_nameの初期化忘れというバグを検出。修復した。

### 型とoffsetとアラインメント

- 言われたとおり、 `Type` 型を追加。ついでに幅を取得する`size_of`を追加。

```c
struct Type {
	enum { INT_, PTR_ } type;
	struct Type *pointer_of;
};
```

- ポインタ型の宣言を構文解析。

- ポインタ型の値を後々入れていくことも考え、offsetを一律8に。

## 2018年7月20日 (Day 11)

- `&` と `*` を実装していきたい。とりあえずアセンブリで実験を重ねる。

- ↓をアセンブリでどう吐くかが分かってきた。

```c
int main()
{
    int x; x = 86;
    int *y; y = &x;
    int **z; z = &y;
    return (*y) + (**z) + 2;
 }
```

- 変数に型情報が必要なので、 `struct VarInfo` を復活させた。といっても、かつてのとは異なり `isDeclared` が滅びているわけだが。そして変数の型情報をinsert。

## 2018年7月21日 (Day 12)

- 型のsizeが8バイトであるときは8バイトをロードするように。

- とりあえず `&` を足すだけ足した。

- 型チェックをするには型の等価性を判定しなくてはいけない。ということで `type.c` を分離してそこに書いていくことにする。

- んー、コンパイラの中にも「型のスタックマシン」を積んで、それを操作して型情報を取得するしかないな。普通なら抽象構文木をちゃんと作って処理するべきなんだろうけど、いまさら足すのもなぁという思いがあるので。

- 現状の `gen_` 系の関数を全てラップするか。んでコンパイラではそっちを呼び出す感じで。

# これ以降日記の更新が途絶えており、1ヶ月経った今（2018年8月21日）ログを見て書いていっている

- 言語学オリンピックの集まりに行った後、[radare2のコミッター](https://twitter.com/Vane11ope)とか[SecHack365経験者](https://twitter.com/megumish)とかとのオフ会に行く。上記の「型のスタックマシン」のアイデアをもとに午前中12コミットほどするも、午後6時台に（時間を潰すべく座る場所を求めて行った）ゲーセンで2コミットしたタイミングでこの方針の愚かさに気づき、急遽午前9:38の4ade413に戻すこととした。

- なお、戒めのためにそのブランチをdesertedという名前でpushしておく。

- コミッターと合流した後もコードを書いていく。とりあえず、desertedブランチのなかでも使い物になりそうなコミット（本筋と関係のなかったコード美化のたぐい）を採用してから、implement_typecheckブランチを立ててやっていった。

### 型チェックの実装

- とりあえず、（理想に反して）まだ構文木が無いので、parse_なんとか_expression系の関数（なんとparseといいながらここで意味解析もコード生成もしているんよな）がvoidではなく式の型（とあとは「ローカル変数かどうか」「ローカル変数だったときそのオフセットはどれほどか」）を含む構造体ExprInfoを返すようにしていった。

- 一気にやるとバグらせるので、一時的にFIXMEという値をExprInfoとして許容し、1関数ずつExprInfoを足していきながら情報が足りないときにはFIXMEで埋める、という方針をとった。この方法は今後も何回か出てくる。

- この日のうちにはFIXMEを消し去るところまで行かなかった。21:00頃に二次会（radare2のコミッターがTwitterで人を追加で呼び急遽開催）が発生し、その後帰って寝たからである。なお、[ログ](https://twilog.org/hsjoihs/date-180722)曰く進捗も出さずに午前2時までTwitterをしていたそうな。

## 2018年7月22日 (Day 13)

- [ログ](https://twilog.org/hsjoihs/date-180722)曰く、起きたのは13時とかのようだ。コードは15時から書き始めている。16時あたりに「通るはずの型チェックが通らない」という現象が起きたらしく、それを特定すべくexpect_typeの第三引数にマジックナンバーを埋め込んでデバッグ、2項&が単項&と衝突するらしいのでとりあえずコメントアウトして4e311d8としてコミット。（おかしいなー再帰下降してるんだから衝突なんて起こるはずないのになー）原因は関数のパラメータに関して型の情報を記録していなかったというだけだったのだが、埋め込まれたマジックナンバーはその後も残り続け、後にコードレビューで指摘されることとなる。

- FIXMEを全て取り除いた。この段階でテストを走らせると089だけが通らない。仕方がないので089をコメントアウトしてコミット。

- アドレス演算子のパーサーでポインタを進め忘れていたというだけの話だった。「通るはずの型チェックが通らない」という現象が起きていたのは、このせいで2項演算子の&の方の処理も通っていたためのようだ。なるほどなぁ。これにより、「パーサー中で変なところを通っていたら、トークンの消費し忘れ=ポインタの進め忘れを疑え」という知見を得た。これは地味に後々のデバッグで役立つのであった。

- ということで無事実装できたので、implement_typecheckブランチをmasterにマージ。

### 間接参照演算子の実装


