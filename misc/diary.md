# C(のサブセット)コンパイラ開発日記

## 2018年7月8日 (Day 1)

- VirtualBoxにUbuntuを入れるのに失敗した。しかたがないのでmacOSで開発する。まあ関数呼び出しとか実装するようになるのはもっと後の話だろうし。

- 課題1（標準入力で数値を受け取り、その数値をreturnする関数のコードを吐く）。やるだけ。入力に乱数を入れたくて、ググったとおりに適当にやったが、なんか上手く行かなかった。macOSのbashの仕様が違うのかもしれないし、私がbashを理解していないのかもしれない。両方か。

- `+` と `-` だけがあるlexerを実装。

- 課題2。とりあえずCPUをスタックマシンにするために頑張ろう。[Compiler Explorer](https://godbolt.org/)のコードを見て、見よう見まねでpushとか演算とかが実装できるようになった。チラ見した他の人のコードには普通に `push` みたいなニーモニックが書いてあったが、まあとりあえず動けばよかろうなのだ。

- lexerとスタックマシンができたのだから、あとは中置をRPNにするだけ。再帰下降パーサーを書けばいいのだが、何を思ったかshunting-yardを実装（しかもまだvectorが無いので有限長の配列）。どうせどこかで挫折するんだろうなぁ

- 無事動いた。やったぜ。

- vectorが欲しいけど、つらくかなしい `void*` よりはメタプログラミングの方がまだマシでは。

- vectorを無事shunting-yardに組み込むことに成功。これにて今日は終わり。

## 2018年7月9日 (Day 2)

- 8日の日記を書いた後に、コードをきれいにして、さらに掛け算を実装。

- 用事とか誕生日とかがあったのでそんなに組めていない。まあ今日はこんなもんでいいや。

- 新機能としては、掛け算が増え、一般に複数の優先順位にだいたい対応できたということぐらいである。どちらかというとコード美化をした一日だった。

## 2018年7月10日

- まったりしていたので進捗なし。たまにはこういう日もある。

## 2018年7月11日 (Day 3)

- まったりしていたらみなさんがとても進捗を出しているの図。

- とりあえず、パーサー拡充して演算子だけでも処理するか。演算子は大量にあるけれど代入とかを除けばだいたい同じだし。

- 除算・剰余・カンマを実装。じゃあ次は比較演算子を実装して2文字の演算子について考えることとするか

- 比較演算子( `< <= > >= == !=` ) と ビット演算子( `& | << >>` ) を実装する途中で、スペースも処理するようにした。

- 単項演算子( `! ~` )を実装したところで、そろそろ変数とかの方に移っていこうか。

## 2018年7月12日 (Day 4)

### 連想配列の実装
- 寝て起きたので日が変わっている。えーと連想配列組まなきゃなんだよな。

- `(char *, int)`というペアの配列で実装しろとのことなので、vectorテンプレートを使う。オレオレテンプレート、やはり便利。

- 実装できたと思う。テストも書いた。

### ローカル変数の実装
- ローカル変数を処理できるようにしよう。%rbpはローカル変数の処理に使うべきで、固定しておくべきっぽいので、いままで%rbpを上下させて実装していたスタックマシンを、%rspを上下させるような仕様に変更。

- 領域を確保するコードを正しく実装できた。さて次はlexerを変数に対応させよう。

- 変数に対応させようとしたら、なんか16進数と8進数が実装されていた。変数に対応させよう。

- とりあえずパーサーが変数を読めるようにした。

### リポジトリ美化

- テストファイルの命名に一貫性がないこと、自動生成されている`.s`が.gitignoreされていないことに関して指摘を受けたので訂正。

### ローカル変数の実装

- さてさて。ローカル変数の実装だ。そろそろshunting-yardだと支障をきたし始める頃だろうか。知らんけど。

## 2018年7月13日 (Day 5)

### ローカル変数の実装

- アセンブリを書いてみたところ、まあ当然右辺値として使うかどうかによって文脈判断が要るので、再帰下降にするしかないことが確定。まあそれはそうだった。最初から再帰下降にしておけばよかったのに。

### リポジトリ美化part2

- 空白はトークンではないのでlexerから削除。

- ヘッダファイルを合流させた。

- テストをまとめたり減らしたりした。
	* 出力ファイルにデバッグ情報を埋め込むことで、わざわざテストをしなくてもデバッグしやすいようになった。
	* `--lexer-debug` オプションを実装することで、わざわざテストをしなくてもデバッグしやすいようになった。
	* それによって不要になったテストを削除。`print_assembly_check009` はcheckではなくsandboxなので、そう改名。

- clang-formatを使用。

- 再帰下降で全部書き直すことに成功。

### 機能追加

- 再帰下降にしたので単項`+`と単項`-`が実装できるように。よって実装。

- 複文を実装。「最後の評価値を戻り値にする」をそのままやるのが面倒だったため、`return`も追加した。`return`の後に更に文が来たときの挙動は現状では未定義とする（実情としては、「評価されるが」返り値には影響を与えない、みたいな挙動になるはず）→ラベル足せばいいことに気づいたので足す。

- 変数aと変数bを使って処理ができるように。

- 任意の名前の変数を許容。

- `^`を実装、さらに条件演算子を実装。

## 2018年7月14日 (Day 6)

### 関数呼び出し

- 関数呼び出しを実装。関数定義ができないので、常に`87`を返す組み込み関数`always87()`を実装することで凌ぐ。

- 引数付きの関数呼び出しを実装。

## 2018年7月15日 (Day 7)

- `parse_compound_statement` を足して、それで全体をparseするように。

- 複数の関数定義（引数なし）をパースできるように。

- 複数の関数定義（引数あり）をパースできるようになり、フィボナッチに成功。

- `&&` を実装。`3 && 2 && 5`とかでも通る。

- `||` を実装。`3 || 2 || 5`とかでも通る。

- `+=` を実装。

- `-=` `*=` `/=` `%=` `<<=` `>>=` `&=` `^=` `|=` を実装。

- `if` - `else` を実装。ちゃんと最も内側の`if`に`else`がくっつく。

- 関数内に複数のルートができたということなので、同一関数内の`return`は必ず同じ場所に返るように修正。

## 2018年7月16日

- 徹夜 → 15:00まで外出 → ( ˘ω˘)ｽﾔｧ

## 2018年7月17日 (Day 8)

- `do` - `while` を実装。

- `while` を実装。また、`;`とコンマ演算子はやっぱり挙動が異なるべきなので、修正。

- `break` を実装。多分。二重ループでもちゃんと正しく動いてるっぽいのでOK。

- `continue` を実装。

## 2018年7月18日 (Day 9)

- バグが検出されたので直した。do-whileの末尾でスタックを余計に押し下げていて、ローカル変数の領域を破壊していたのが原因だった。

- いい加減vectorを`void *`に統一しなければならないので、その移行の準備をした。

- 前置・後置の`++` と `--` を実装。

- 「lexerを2回実行して、1回目でトークン数を数えて2回目でその分をcallocする」とすれば `vector_Token` が不要になるので、そうした。

- intmap以外でのvectorの使用を廃することに成功したので、vectorをintmapの中に放り込んで怒涛のinline化。そしてリポジトリからテンプレート機構を削除。

- 第三式が無いfor文を実装。

- 第三式があるときにもfor文を実装。（あれ、コメントアウトで書いているけど2重ループでマズいのでは）（←大丈夫。第三式自体にforが出なければよくて、forは文なので第三式には出てこない）

## 2018年7月19日 (Day 10)

- ソースコードから配列を追放。これで多分すべての変数宣言が `型名 名前;` と見なせる

- `型名 名前;` を構文解析

- `int_map` は `int` じゃなくて `void*` を取るように。それに沿って `map` に改名。

- 変数が宣言されていないとエラーになるようにした。

### スコープ

- ちゃんとスコープを見てやらねばなのである。ということで、現状の `map` での管理では限界があろう。ブロックの内外で変数名が衝突することもあるのだし。

- 変数用の領域を確保する処理は割と現状のままでよくて（現状だと多めに取ることになるが、多い分には困らない）、名前解決を直さねば。

- 現状では、関数に入る際に、それ以降に登場する全ての識別子を数え、それに `offset` を振っている。しかしこれだとスコープの内外で変数名が衝突したときに困るので、最初は全ての識別子を重複を含めて数え、 `offset` は振らないでおく。

- まずデータ構造を考えよう。中から外を見なければいけないが、外からは中は見えなくて良い。ということで、外へ外へと伸びていくリンクリストにすればよさそうではある。

- さてどう移行していこうか。とりあえず `var_table` を `old_var_table` にしよう。次に、 `capacity` の確保をする際には重複して数えるようにしよう。

- とりあえず片方向リンクリストの型を入れておいた。まだリンクリストにはなっていないけど。

- `isDeclared` を一旦捨てて、直に `offset` を`void*`にキャストする方針へ。これにより`calloc`を廃す。

- 宣言されてから初めて`insert`するようにした。動いた。

- 多分リンクリストが実装できた。知らんけど。

- スコープチェーンが動いていることを確認。

### 雑多

- ついでに、関数名の前に型を要求。これで `supplement.c` を自力でコンパイルできるように。

- 誤ったCに対してエラーを吐く方に関してはテストをしていなかったので、テストをしようとしたところ、continue_label_nameの初期化忘れというバグを検出。修復した。

### 型とoffsetとアラインメント

- 言われたとおり、 `Type` 型を追加。ついでに幅を取得する`size_of`を追加。

```c
struct Type {
	enum { INT_, PTR_ } type;
	struct Type *pointer_of;
};
```

- ポインタ型の宣言を構文解析。

- ポインタ型の値を後々入れていくことも考え、offsetを一律8に。

## 2018年7月20日 (Day 11)

- `&` と `*` を実装していきたい。とりあえずアセンブリで実験を重ねる。

- ↓をアセンブリでどう吐くかが分かってきた。

```c
int main()
{
    int x; x = 86;
    int *y; y = &x;
    int **z; z = &y;
    return (*y) + (**z) + 2;
 }
```

- 変数に型情報が必要なので、 `struct VarInfo` を復活させた。といっても、かつてのとは異なり `isDeclared` が滅びているわけだが。そして変数の型情報をinsert。

## 2018年7月21日 (Day 12)

- 型のsizeが8バイトであるときは8バイトをロードするように。

- とりあえず `&` を足すだけ足した。

- 型チェックをするには型の等価性を判定しなくてはいけない。ということで `type.c` を分離してそこに書いていくことにする。

- んー、コンパイラの中にも「型のスタックマシン」を積んで、それを操作して型情報を取得するしかないな。普通なら抽象構文木をちゃんと作って処理するべきなんだろうけど、いまさら足すのもなぁという思いがあるので。

- 現状の `gen_` 系の関数を全てラップするか。んでコンパイラではそっちを呼び出す感じで。

# これ以降日記の更新が途絶えており、1ヶ月経った今（2018年8月21日）ログを見て書いていっている

- 言語学オリンピックの集まりに行った後、[radare2のコミッター](https://twitter.com/Vane11ope)とか[SecHack365経験者](https://twitter.com/megumish)とかとのオフ会に行く。上記の「型のスタックマシン」のアイデアをもとに午前中12コミットほどするも、午後6時台に（時間を潰すべく座る場所を求めて行った）ゲーセンで2コミットしたタイミングでこの方針の愚かさに気づき、急遽午前9:38の4ade413に戻すこととした。

- なお、戒めのためにそのブランチをdesertedという名前でpushしておく。

- コミッターと合流した後もコードを書いていく。とりあえず、desertedブランチのなかでも使い物になりそうなコミット（本筋と関係のなかったコード美化のたぐい）を採用してから、implement_typecheckブランチを立ててやっていった。

### 型チェックの実装

- とりあえず、（理想に反して）まだ構文木が無いので、parse_なんとか_expression系の関数（なんとparseといいながらここで意味解析もコード生成もしているんよな）がvoidではなく式の型（とあとは「ローカル変数かどうか」「ローカル変数だったときそのオフセットはどれほどか」）を含む構造体ExprInfoを返すようにしていった。

- 一気にやるとバグらせるので、一時的にFIXMEという値をExprInfoとして許容し、1関数ずつExprInfoを足していきながら情報が足りないときにはFIXMEで埋める、という方針をとった。この方法は今後も何回か出てくる。

- この日のうちにはFIXMEを消し去るところまで行かなかった。21:00頃に二次会（radare2のコミッターがTwitterで人を追加で呼び急遽開催）が発生し、その後帰って寝たからである。なお、[ログ](https://twilog.org/hsjoihs/date-180722)曰く進捗も出さずに午前2時までTwitterをしていたそうな。

## 2018年7月22日 (Day 13)

- [ログ](https://twilog.org/hsjoihs/date-180722)曰く、起きたのは13時とかのようだ。コードは15時から書き始めている。16時あたりに「通るはずの型チェックが通らない」という現象が起きたらしく、それを特定すべくexpect_typeの第三引数にマジックナンバーを埋め込んでデバッグ、2項&が単項&と衝突するらしいのでとりあえずコメントアウトして4e311d8としてコミット。（おかしいなー再帰下降してるんだから衝突なんて起こるはずないのになー）原因は関数のパラメータに関して型の情報を記録していなかったというだけだったのだが、埋め込まれたマジックナンバーはその後も残り続け、後にコードレビューで指摘されることとなる。

- FIXMEを全て取り除いた。この段階でテストを走らせると089だけが通らない。仕方がないので089をコメントアウトしてコミット。

- アドレス演算子のパーサーでポインタを進め忘れていたというだけの話だった。「通るはずの型チェックが通らない」という現象が起きていたのは、このせいで2項演算子の&の方の処理も通っていたためのようだ。なるほどなぁ。これにより、「パーサー中で変なところを通っていたら、トークンの消費し忘れ=ポインタの進め忘れを疑え」という知見を得た。これは地味に後々のデバッグで役立つのであった。

- ということで無事実装できたので、implement_typecheckブランチをmasterにマージ。

### 間接参照演算子・複雑な左辺を持つ代入文の実装

- 型チェッカーができたので、「右辺値としての」 `*` の実装は楽である。ポインタ型であるかどうかを確認して（←これを書くために型チェッカーが必要だったのだなぁ）、PTR_ノードを型から取り除いて、アドレスから値を得ればOK。テストも通る。

- さて、問題は左辺値である。自分でもあまり分かっていなかった印象があったので、恒例のごとくとりあえずgccが吐いたアセンブリを読んで式変形していこう。

## 2018年7月23日 (Day 14)

- 複合代入演算子も考えておいたほうがいいよなぁ。これまたアセンブリを読んでいこう。ふむふむ、先に右辺値として処理する際に、`*`される前のアドレスを隠しローカル変数に退避しておけば、「実は左辺値でしたー」となったときも対応できるな。さらに、複合代入演算子の場合は右辺値としての値と左辺値としての値が両方必要になるわけだ。ますますこの方法が適しているだろう。

（編注：当然であるが、構文木さえ作っていれば、こんなトリック使わずとも「右辺値と左辺値のコード生成を分離する」だけで十分なのである。）

- 寝て起きた。ということで、ローカル変数の領域を増やしてアドレスをバックアップしよう。（編注：なぜか44e2c5dのコミットメッセージはback up the **register** とか書いてある。addressの間違いに決まっているんだよなぁ。）

- Cの構文規則では、assignment-expressionはこう定義されている。

```
assignment-expression:
                 conditional-expression
                 unary-expression assignment-operator assignment-expression
```

- ということは、「試しにunary-expressionを読んでみて、その直後にassignment-operatorが来ていなかった場合はその情報を破棄し、conditional-expressionとして読む」と実装しなければならない。しかし、現状ではparseしたら同時にコード生成もしてしまう。

- コード生成のオンオフを切り替える機能を実装することも一瞬考えたが、あまりに面倒である。かといって、ネストする可能性があるのでfor文のときと違ってコメントで処理はできない。

- …そうだ、ジャンプですっ飛ばせば事実上のコメントアウトではないか！

（編注：当然であるが、構文木さえ作っていれば、こんなトリックは一切不要なのである。）

- とまあそんな迷案を思いついてしまったので実装。ついでにfor文の第三式もコメントではなくこの方法で処理するように。

- `*ident` とかがlvalueとして使えるようになった。

- assignment-expressionがネストする際、バックアップ領域が上書きされてしまうのを防ぐために、バックアップをさらにスタックに積み直すように。これにより `a = b = 5;` が動く。

（編注：当然であるが、構文木さえ【以下略】）

### `alloc4` のための準備

- さて、資料に従ってポインタ演算のテストをするには、「intの値を4つ引数に与えるとその引数を要素数4の配列に突っ込んでくれる」という関数alloc4を作ってgccでコンパイルし、リンクする必要がある。そのためには関数にポインタを渡したり、関数からポインタを返したりする必要がある。関数呼び出し周りが4byteの引数しか対応していないので、修正が必要だ。

- アセンブリを眺め、「あっこれ `movq` にしないとダメだな」とかを検出しつつ、コード片を `print_x86_64.c` に送っていく。

- ポインタを関数に渡したりとかをできるようにすべく、そのための8バイト用コード片とかを足した。

- ParserState が関数の戻り値の型をメモるようにしたので、戻り値の型チェックができるようになった。

## 2018年7月24日 (Day 15)

- 他の関数の戻り値の型を `func_ret_type_map` というmapに入れておいて、呼ぶ方も型チェックをするように。ん、となると、資料に書いてある `alloc4` を実現するにはプロトタイプ宣言を足さないといけないな。

（編注：当時の資料のalloc4は確保した配列をポインタで返していた。int以外の値を返しているこのような関数を書くにはプロトタイプ宣言が必要ではないかと指摘し、今では「`alloc4`の第一引数に`int **`を渡し、そこ経由でポインタを入手する」ように書き換わっている。）

- 8バイト用コード片を足したのでポインタを関数から返せるようになった。

- 前述の理由によりプロトタイプ宣言を追加。

### ポインタ演算

- ポインタ演算を実装すべくgccの吐いたアセンブリで実験。 `cltq` という命令について学ぶ。

## 2018年7月25日 (Day 16)

- ポインタ演算（pointer + int）を実装。ちなみにこの段階で`alloc4`の呼び出しが16バイトアラインメント制約に抵触しており、手動で変数を足してアラインメントをアドホックに揃えている。

- 16バイトアラインメントを必ず満たすようにする方法を考える。思いついたのは以下の方法。
	- まずスタックを8バイト伸ばす。
	- rspと15でbitandし、rspを16で割ったときの余りを得る。
	- その余りの分だけスタックを伸ばし、余りをスタックのトップに格納してからcallする
	- 戻ってきたら、スタックのトップに書いてある値の分だけスタックを縮める。
	- スタックのトップに戻り値を書き込む。
- こうすれば、最初に伸ばした8バイトのところに必ず戻り値が書き込まれ、かつcallの直前には必ず16バイトにアラインされている。

## 2018年7月26日 (Day 17)

- pointer - intとかint + pointerとかも実装。

- ポインタ演算のために掛け算するsizeofは1, 2, 4, 8だけ考えていればいいと思い込んでいたが、よく考えると配列へのポインタに関してはその限りではない。ということで任意のサイズを許すように。

## 2018年7月27日

- ログを見る限り、徹夜してTwitterをして東大に行ってオフ会をしている。昼頃に人と会い、15:46頃に人が漢詩を作っている（押韻と平仄に苦しんでいた）のを見たりして、19:00あたりまで寝て、一人と会って帰っている。Cコンパイラの進捗は皆無である。

## 2018年7月28日 (Day 18)

### 配列

- 配列を実装することを考え始める。まずは構造体Typeで配列を扱えるようにするのが先決だ。

- 現状の関数定義のパーサー（もちろんコード生成と混じっている）は `ret_type func_name(arg_list){}` の形にしか対応していない。これを読んでいる人の中には「えっ、Cの関数定義の構文ってそうじゃないの？」と思っている人もいるかもしれないが、そうではない。例えば、 `int a[3][5];` で定義される2次元配列 `a` を関数に渡し、関数では渡された `a` をそのまま返しているとしよう。その場合、その関数の定義は

```c
int (*func(int (*a)[5]))[5]
{
    return a;
}
```

または

```c
int (*func(int a[3][5]))[5]
{
    return a;
}
```

となる。

- 今までは `int *foo()` というのを「型名 `int *`を読んで、識別子を読んで、カッコを読む」としていたが、配列が入ってくるとこれは破綻する。

- ここまで複雑な例でなくても、「配列へのポインタ」を書きたいだけでも `int (*a)[5];` と書かねばならない。配列の構文をサポートしろと書いてあるのだから、こういうケースもちゃんとサポートしてやらねばならない。

（編注：後になって分かることだが、この理解は **誤り** であった。資料には「 `int a[10];` のような変数定義を読み込めるようにしてください。」としか書いておらず、配列へのポインタだったりそれを返す関数だったりの構文解析をしろとはどこにも書いていない。）

- なら、いっそのこと型関連の純粋なパーサーを新規に書き下してやろう。そうすれば現状の「パーサーとコード生成が混じっている」という現状を改善する取っ掛かりにもなるだろう。

- `int *a;` とか `int *foo(){}` とかを読んでいた箇所では、今までは `int *foo` 箇所を「型名 + 識別子」として読んでいた。しかし、この解釈は誤りであるので、この箇所を `parse_var_declarator` という名前で抜き出し、構文規則に合ったコードで再解釈していくことを目標とする。

## 2018年7月29日 (Day 19)

### ローカル変数の容量

- 「スコープ」のところに「現状では、関数に入る際に、それ以降に登場する全ての識別子を数え、それに `offset` を振っている。しかしこれだとスコープの内外で変数名が衝突したときに困るので、最初は全ての識別子を重複を含めて数え、 `offset` は振らないでおく。」などというすごいことが書かれている。これは、「構文解析とコード生成を同時に行っている以上、関数が要求するローカル変数用の領域の大きさが関数の最後までわからない」という本質的な課題から逃げるための一時しのぎである。

- しかし、配列が入ってくると、識別子の数を数えたところで十分な領域が確保できるとは限らなくなってしまう。ということは、関数を末尾まで読んで初めてローカル変数の容量が確定する。しかしローカル変数用の領域は関数の先頭で確保される。さてどうしよう。

（編注：当然であるが、構【以下略】）

- そうだ、領域を確保するコードは関数の末尾に書いて、関数の先頭にはそこに飛ぶラベルを書けばいいんだ。（←は？？？？）汚いけど動くからセーフ。うんうん。

（編注：アウト。いやまあfor文の第三式をコメントアウトで処理し始めた時点で既にだいぶアウトだった感は否めないが）

- ローカル変数のsizeに応じてスタックを確保するようにした。前は最高が8だったので識別子が出るたびに8だけ確保していたが。

### 型の構文

- 「型名 + 識別子」は嘘なので、 `parse_type_name` とかいう関数をinlineして `parse_var_declarator` として処理していくように。アスタリスクは識別子の方にくっつくのだということを `parse_var_declarator` に教えていきたい。

- `parse_var_declarator` は `ptr_ps` も コード生成も含まない純粋なパーサーなので、 `type.c` に送る。

- K&Rを参考にして、 `parse_var_declarator` から `parse_dcl` （`*a` を処理）を分離したり、アスタリスクは先に数えるだけ数えて後で型を構成したりするようにした。

- `parse_dcl` から `parse_dirdcl` を分離。

- `parse_dirdcl` にカッコを許容。（ `int *(*p);` とかが書けるように。）

- そういえばlexerにまだ角括弧を教えていなかったので追加。

## 2018年7月30日 (Day 20)

- 日付は変わって7月30日。もう7月も終わる頃か。




